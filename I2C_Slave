`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 31.05.2024 13:56:03
// Design Name: 
// Module Name: I2C
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////
module I2C_master(sda,scl,reset,start,clk,data_in,address,data_out);
input reset,start,clk;
input [7:0] data_in;
output reg [7:0] data_out;
input [7:0] address; // 6 bits address and last bit read or write

inout wire sda;
inout wire scl;
reg sda_enable;
reg scl_enable=0;
reg sda_out;
reg [3:0] pstate;
integer i;
parameter idle=4'b0000,start_state=4'b0001,addr=4'b0010,add_ack=4'b0011,
write=4'b0100,write_ack=4'b0101, read=4'b0110, read_ack=4'b0111, stop=4'b1000;

assign scl = (scl_enable) ? clk : 1;
assign sda = (sda_enable) ? sda_out : 1'bz;

initial pstate=idle;

always @(posedge clk or posedge reset)
begin
if(reset)
pstate<=idle;
else
    case(pstate)
    
    idle: begin
    if(start) begin  //if start==1 then we move to the start state
                pstate<=start_state;  //1
               end
     else pstate<=idle;
    end 
    start_state: begin
                i=7;
                pstate<=addr;
                end 
    addr: begin
          if(i==0) pstate<=add_ack;
          else i=i-1;                //for each posedge a bit from address+read/write is fed into the sda in negedge block
          end
          
    add_ack: begin
              if(sda==0) begin
                  i=7; 
                  if(address[0]==0) pstate<=write;
                  else pstate<=read;      
                  end                          //making the count =7 so that data is read or written
              else pstate<=stop;
              end
              
    write: begin
            if(i==0) pstate<=write_ack;
            else i=i-1;
            end
         
    write_ack: begin
                if(sda==0 && start==1) pstate<=idle;
                else pstate<=stop;    
               end
               
    read: begin
           data_out[i]<=sda;
           if(i==0) pstate<=read_ack;
           else i=i-1;
          end
          
    read_ack: begin
                pstate<=stop;
               end
    stop: begin
           pstate<=idle;
          end
    endcase
end


always @(negedge clk,posedge reset)
begin
    if(reset==1) begin
        sda_enable<=1;
        sda_out<=1;
        scl_enable<=0;
      end
      else begin
      case(pstate)
      start_state: begin
        sda_enable<=1;
        sda_out<=0; 
      end
      
      addr: begin
        sda_out<=address[i];
      end
      
      add_ack: begin
        sda_enable<=0; //slave controls sda output here;
      end
      
      write: begin
        sda_enable<=1;
        sda_out<=data_in[i];
      end
      
      write_ack: begin
        sda_enable<=0;
      end
      
      read_ack: begin
        sda_enable<=1;
        sda_out<=0;
      end
      
      read : begin
        sda_enable<=0;
      end
      
      stop: begin 
        sda_enable<=1;
        sda_out<=1;
      end
      
      idle: begin
      sda_enable<=1;
      sda_out<=1;
      end
      endcase
      end
end

always @(negedge clk,posedge reset)
begin
if((pstate==idle )|| (pstate==stop) ||(reset==1) || (pstate==start_state)) scl_enable<=0;
else scl_enable<=1;
end

endmodule

////slave code
module i2c_slave(sda,scl);
inout wire sda,scl;

parameter address = 7'b1010110;
parameter read_addr= 3'b0 , ack1 = 3'b01, read = 3'b10, write = 3'b11, ack2 = 3'b100;

reg [7:0] addr;
integer i; //1
reg [2:0] pstate;
reg [7:0] data_in;
reg [7:0] data_out=8'b01101101;
reg sda_out=0,start=0,sda_enable=0;

assign sda = (sda_enable) ? sda_out : 1'bz;
initial i=7;
initial pstate=read_addr; //3

always @(negedge sda) begin
    if((start==0)) begin    //  to detect the start condition
        start<=1;
        i=7;
    end
end

always @(posedge sda) begin
    if((start==1) && (scl==1)) begin    // to detect the stop condition
        pstate<=read_addr;
        start<=0;
        sda_enable<=0;
    end
end

always @(posedge scl) begin
    if(start==1) begin
    case(pstate)
    read_addr: begin
        addr[i]<=sda;
        if(i==0) pstate<=ack1;
        else i=i-1;
    end
    ack1: begin
    if(addr[7:1]==address)begin
        i=7;
        if(addr[0]==1) pstate<=write;
        else pstate<=read;
    end     
    end
   
    read: begin
        data_in[i]<= sda;
        if(i==0) pstate<=ack2;
        else i=i-1;
    end
    
    ack2: begin
        pstate<=read_addr;
    end
    
    write: begin
    if(i==0) pstate<=read_addr;
    else i=i-1;
    end
    endcase
    end
end

always @(negedge scl) begin
    case(pstate)
    
    read_addr: begin
    sda_enable<=0;  //sda works according to master here
    end
    
    ack1: begin
    sda_out<=0;
    sda_enable<=1;
    end
    
    read: begin
    sda_enable<=0; //sda works acc to master
    end
    
    ack2: begin
    sda_out<=0;
    sda_enable<=1;
    end
    
    write: begin
    sda_out<=data_out[i];
    sda_enable<=1;
    end
    endcase
end

endmodule
